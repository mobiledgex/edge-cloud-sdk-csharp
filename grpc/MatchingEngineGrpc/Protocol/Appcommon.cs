// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: appcommon.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace DistributedMatchEngine {

  /// <summary>Holder for reflection information generated from appcommon.proto</summary>
  public static partial class AppcommonReflection {

    #region Descriptor
    /// <summary>File descriptor for appcommon.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AppcommonReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg9hcHBjb21tb24ucHJvdG8SGGRpc3RyaWJ1dGVkX21hdGNoX2VuZ2luZRog",
            "Z29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG8aEmVkZ2Vwcm90b2dl",
            "bi5wcm90byK/AQoHQXBwUG9ydBIvCgVwcm90bxgBIAEoDjIgLmRpc3RyaWJ1",
            "dGVkX21hdGNoX2VuZ2luZS5MUHJvdG8SFQoNaW50ZXJuYWxfcG9ydBgCIAEo",
            "BRITCgtwdWJsaWNfcG9ydBgDIAEoBRITCgtmcWRuX3ByZWZpeBgFIAEoCRIQ",
            "CghlbmRfcG9ydBgGIAEoBRILCgN0bHMYByABKAgSDQoFbmdpbngYCCABKAgS",
            "FAoMbWF4X3BrdF9zaXplGAkgASgDIjsKEERldmljZUluZm9TdGF0aWMSEQoJ",
            "ZGV2aWNlX29zGAEgASgJEhQKDGRldmljZV9tb2RlbBgCIAEoCSJdChFEZXZp",
            "Y2VJbmZvRHluYW1pYxIZChFkYXRhX25ldHdvcmtfdHlwZRgBIAEoCRIXCg9z",
            "aWduYWxfc3RyZW5ndGgYAiABKAQSFAoMY2Fycmllcl9uYW1lGAMgASgJKj8K",
            "BkxQcm90bxITCg9MX1BST1RPX1VOS05PV04QABIPCgtMX1BST1RPX1RDUBAB",
            "Eg8KC0xfUFJPVE9fVURQEAIqqAEKC0hlYWx0aENoZWNrEhgKFEhFQUxUSF9D",
            "SEVDS19VTktOT1dOEAASJAogSEVBTFRIX0NIRUNLX0ZBSUxfUk9PVExCX09G",
            "RkxJTkUQARIhCh1IRUFMVEhfQ0hFQ0tfRkFJTF9TRVJWRVJfRkFJTBACEhMK",
            "D0hFQUxUSF9DSEVDS19PSxADEiEKHUhFQUxUSF9DSEVDS19DTE9VRExFVF9P",
            "RkZMSU5FEAQq7wEKDUNsb3VkbGV0U3RhdGUSGgoWQ0xPVURMRVRfU1RBVEVf",
            "VU5LTk9XThAAEhkKFUNMT1VETEVUX1NUQVRFX0VSUk9SUxABEhgKFENMT1VE",
            "TEVUX1NUQVRFX1JFQURZEAISGgoWQ0xPVURMRVRfU1RBVEVfT0ZGTElORRAD",
            "Eh4KGkNMT1VETEVUX1NUQVRFX05PVF9QUkVTRU5UEAQSFwoTQ0xPVURMRVRf",
            "U1RBVEVfSU5JVBAFEhoKFkNMT1VETEVUX1NUQVRFX1VQR1JBREUQBhIcChhD",
            "TE9VRExFVF9TVEFURV9ORUVEX1NZTkMQByrAAgoQTWFpbnRlbmFuY2VTdGF0",
            "ZRIUChBOT1JNQUxfT1BFUkFUSU9OEAASFQoRTUFJTlRFTkFOQ0VfU1RBUlQQ",
            "ARIcChJGQUlMT1ZFUl9SRVFVRVNURUQQAhoEkPYYARIXCg1GQUlMT1ZFUl9E",
            "T05FEAMaBJD2GAESGAoORkFJTE9WRVJfRVJST1IQBBoEkPYYARIhCh1NQUlO",
            "VEVOQU5DRV9TVEFSVF9OT19GQUlMT1ZFUhAFEhcKDUNSTV9SRVFVRVNURUQQ",
            "BhoEkPYYARIfChVDUk1fVU5ERVJfTUFJTlRFTkFOQ0UQBxoEkPYYARITCglD",
            "Uk1fRVJST1IQCBoEkPYYARIfChVOT1JNQUxfT1BFUkFUSU9OX0lOSVQQCRoE",
            "kPYYARIbChFVTkRFUl9NQUlOVEVOQU5DRRAfGgSQ9hgBYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { pbr::FileDescriptor.DescriptorProtoFileDescriptor, global::Edgeprotogen.EdgeprotogenReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::DistributedMatchEngine.LProto), typeof(global::DistributedMatchEngine.HealthCheck), typeof(global::DistributedMatchEngine.CloudletState), typeof(global::DistributedMatchEngine.MaintenanceState), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::DistributedMatchEngine.AppPort), global::DistributedMatchEngine.AppPort.Parser, new[]{ "Proto", "InternalPort", "PublicPort", "FqdnPrefix", "EndPort", "Tls", "Nginx", "MaxPktSize" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::DistributedMatchEngine.DeviceInfoStatic), global::DistributedMatchEngine.DeviceInfoStatic.Parser, new[]{ "DeviceOs", "DeviceModel" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::DistributedMatchEngine.DeviceInfoDynamic), global::DistributedMatchEngine.DeviceInfoDynamic.Parser, new[]{ "DataNetworkType", "SignalStrength", "CarrierName" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Layer4 Protocol
  ///
  /// LProto indicates which protocol to use for accessing an application on a particular port. This is required by Kubernetes for port mapping.
  ///
  /// 0: `L_PROTO_UNKNOWN`
  /// 1: `L_PROTO_TCP`
  /// 2: `L_PROTO_UDP`
  /// </summary>
  public enum LProto {
    /// <summary>
    /// Unknown protocol
    /// </summary>
    [pbr::OriginalName("L_PROTO_UNKNOWN")] Unknown = 0,
    /// <summary>
    /// TCP (L4) protocol
    /// </summary>
    [pbr::OriginalName("L_PROTO_TCP")] Tcp = 1,
    /// <summary>
    /// UDP (L4) protocol
    /// </summary>
    [pbr::OriginalName("L_PROTO_UDP")] Udp = 2,
  }

  /// <summary>
  /// Health check status
  ///
  /// Health check status gets set by external, or rootLB health check
  /// </summary>
  public enum HealthCheck {
    /// <summary>
    /// Health Check is unknown
    /// </summary>
    [pbr::OriginalName("HEALTH_CHECK_UNKNOWN")] Unknown = 0,
    /// <summary>
    /// Health Check failure due to RootLB being offline
    /// </summary>
    [pbr::OriginalName("HEALTH_CHECK_FAIL_ROOTLB_OFFLINE")] FailRootlbOffline = 1,
    /// <summary>
    /// Health Check failure due to Backend server being unavailable
    /// </summary>
    [pbr::OriginalName("HEALTH_CHECK_FAIL_SERVER_FAIL")] FailServerFail = 2,
    /// <summary>
    /// Health Check is ok
    /// </summary>
    [pbr::OriginalName("HEALTH_CHECK_OK")] Ok = 3,
    /// <summary>
    /// Health Check failure due to Cloudlet Offline
    /// </summary>
    [pbr::OriginalName("HEALTH_CHECK_CLOUDLET_OFFLINE")] CloudletOffline = 4,
  }

  /// <summary>
  /// CloudletState is the state of the Cloudlet.
  /// </summary>
  public enum CloudletState {
    /// <summary>
    /// Unknown
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_UNKNOWN")] Unknown = 0,
    /// <summary>
    /// Create/Delete/Update encountered errors (see Errors field of CloudletInfo)
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_ERRORS")] Errors = 1,
    /// <summary>
    /// Cloudlet is created and ready
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_READY")] Ready = 2,
    /// <summary>
    /// Cloudlet is offline (unreachable)
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_OFFLINE")] Offline = 3,
    /// <summary>
    /// Cloudlet is not present
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_NOT_PRESENT")] NotPresent = 4,
    /// <summary>
    /// Cloudlet is initializing
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_INIT")] Init = 5,
    /// <summary>
    /// Cloudlet is upgrading
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_UPGRADE")] Upgrade = 6,
    /// <summary>
    /// Cloudlet needs data to synchronize
    /// </summary>
    [pbr::OriginalName("CLOUDLET_STATE_NEED_SYNC")] NeedSync = 7,
  }

  /// <summary>
  /// Cloudlet Maintenance States
  ///
  /// Maintenance allows for planned downtimes of Cloudlets.
  /// These states involve message exchanges between the Controller,
  /// the AutoProv service, and the CRM. Certain states are only set
  /// by certain actors.
  /// </summary>
  public enum MaintenanceState {
    /// <summary>
    /// Normal operational state
    /// </summary>
    [pbr::OriginalName("NORMAL_OPERATION")] NormalOperation = 0,
    /// <summary>
    /// Request start of maintenance
    /// </summary>
    [pbr::OriginalName("MAINTENANCE_START")] MaintenanceStart = 1,
    /// <summary>
    /// Trigger failover for any HA AppInsts
    /// </summary>
    [pbr::OriginalName("FAILOVER_REQUESTED")] FailoverRequested = 2,
    /// <summary>
    /// Failover done
    /// </summary>
    [pbr::OriginalName("FAILOVER_DONE")] FailoverDone = 3,
    /// <summary>
    /// Some errors encountered during maintenance failover
    /// </summary>
    [pbr::OriginalName("FAILOVER_ERROR")] FailoverError = 4,
    /// <summary>
    /// Request start of maintenance without AutoProv failover
    /// </summary>
    [pbr::OriginalName("MAINTENANCE_START_NO_FAILOVER")] MaintenanceStartNoFailover = 5,
    /// <summary>
    /// Request CRM to transition to maintenance
    /// </summary>
    [pbr::OriginalName("CRM_REQUESTED")] CrmRequested = 6,
    /// <summary>
    /// CRM request done and under maintenance
    /// </summary>
    [pbr::OriginalName("CRM_UNDER_MAINTENANCE")] CrmUnderMaintenance = 7,
    /// <summary>
    /// CRM failed to go into maintenance
    /// </summary>
    [pbr::OriginalName("CRM_ERROR")] CrmError = 8,
    /// <summary>
    /// Request CRM to transition to normal operation
    /// </summary>
    [pbr::OriginalName("NORMAL_OPERATION_INIT")] NormalOperationInit = 9,
    /// <summary>
    /// Under maintenance
    /// </summary>
    [pbr::OriginalName("UNDER_MAINTENANCE")] UnderMaintenance = 31,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Application Port
  ///
  /// AppPort describes an L4 or L7 public access port/path mapping. This is used to track external to internal mappings for access via a shared load balancer or reverse proxy.
  /// </summary>
  public sealed partial class AppPort : pb::IMessage<AppPort> {
    private static readonly pb::MessageParser<AppPort> _parser = new pb::MessageParser<AppPort>(() => new AppPort());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AppPort> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DistributedMatchEngine.AppcommonReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AppPort() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AppPort(AppPort other) : this() {
      proto_ = other.proto_;
      internalPort_ = other.internalPort_;
      publicPort_ = other.publicPort_;
      fqdnPrefix_ = other.fqdnPrefix_;
      endPort_ = other.endPort_;
      tls_ = other.tls_;
      nginx_ = other.nginx_;
      maxPktSize_ = other.maxPktSize_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AppPort Clone() {
      return new AppPort(this);
    }

    /// <summary>Field number for the "proto" field.</summary>
    public const int ProtoFieldNumber = 1;
    private global::DistributedMatchEngine.LProto proto_ = 0;
    /// <summary>
    /// TCP (L4) or UDP (L4) protocol
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::DistributedMatchEngine.LProto Proto {
      get { return proto_; }
      set {
        proto_ = value;
      }
    }

    /// <summary>Field number for the "internal_port" field.</summary>
    public const int InternalPortFieldNumber = 2;
    private int internalPort_;
    /// <summary>
    /// Container port
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int InternalPort {
      get { return internalPort_; }
      set {
        internalPort_ = value;
      }
    }

    /// <summary>Field number for the "public_port" field.</summary>
    public const int PublicPortFieldNumber = 3;
    private int publicPort_;
    /// <summary>
    /// Public facing port for TCP/UDP (may be mapped on shared LB reverse proxy)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PublicPort {
      get { return publicPort_; }
      set {
        publicPort_ = value;
      }
    }

    /// <summary>Field number for the "fqdn_prefix" field.</summary>
    public const int FqdnPrefixFieldNumber = 5;
    private string fqdnPrefix_ = "";
    /// <summary>
    /// skip 4 to preserve the numbering. 4 was path_prefix but was removed since we dont need it after removed http
    /// FQDN prefix to append to base FQDN in FindCloudlet response. May be empty.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string FqdnPrefix {
      get { return fqdnPrefix_; }
      set {
        fqdnPrefix_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "end_port" field.</summary>
    public const int EndPortFieldNumber = 6;
    private int endPort_;
    /// <summary>
    /// A non-zero end port indicates a port range from internal port to end port, inclusive.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int EndPort {
      get { return endPort_; }
      set {
        endPort_ = value;
      }
    }

    /// <summary>Field number for the "tls" field.</summary>
    public const int TlsFieldNumber = 7;
    private bool tls_;
    /// <summary>
    /// TLS termination for this port
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Tls {
      get { return tls_; }
      set {
        tls_ = value;
      }
    }

    /// <summary>Field number for the "nginx" field.</summary>
    public const int NginxFieldNumber = 8;
    private bool nginx_;
    /// <summary>
    /// Use nginx proxy for this port if you really need a transparent proxy (udp only)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Nginx {
      get { return nginx_; }
      set {
        nginx_ = value;
      }
    }

    /// <summary>Field number for the "max_pkt_size" field.</summary>
    public const int MaxPktSizeFieldNumber = 9;
    private long maxPktSize_;
    /// <summary>
    /// Maximum datagram size (udp only)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long MaxPktSize {
      get { return maxPktSize_; }
      set {
        maxPktSize_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AppPort);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AppPort other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Proto != other.Proto) return false;
      if (InternalPort != other.InternalPort) return false;
      if (PublicPort != other.PublicPort) return false;
      if (FqdnPrefix != other.FqdnPrefix) return false;
      if (EndPort != other.EndPort) return false;
      if (Tls != other.Tls) return false;
      if (Nginx != other.Nginx) return false;
      if (MaxPktSize != other.MaxPktSize) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Proto != 0) hash ^= Proto.GetHashCode();
      if (InternalPort != 0) hash ^= InternalPort.GetHashCode();
      if (PublicPort != 0) hash ^= PublicPort.GetHashCode();
      if (FqdnPrefix.Length != 0) hash ^= FqdnPrefix.GetHashCode();
      if (EndPort != 0) hash ^= EndPort.GetHashCode();
      if (Tls != false) hash ^= Tls.GetHashCode();
      if (Nginx != false) hash ^= Nginx.GetHashCode();
      if (MaxPktSize != 0L) hash ^= MaxPktSize.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Proto != 0) {
        output.WriteRawTag(8);
        output.WriteEnum((int) Proto);
      }
      if (InternalPort != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(InternalPort);
      }
      if (PublicPort != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(PublicPort);
      }
      if (FqdnPrefix.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(FqdnPrefix);
      }
      if (EndPort != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(EndPort);
      }
      if (Tls != false) {
        output.WriteRawTag(56);
        output.WriteBool(Tls);
      }
      if (Nginx != false) {
        output.WriteRawTag(64);
        output.WriteBool(Nginx);
      }
      if (MaxPktSize != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(MaxPktSize);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Proto != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Proto);
      }
      if (InternalPort != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(InternalPort);
      }
      if (PublicPort != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PublicPort);
      }
      if (FqdnPrefix.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FqdnPrefix);
      }
      if (EndPort != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndPort);
      }
      if (Tls != false) {
        size += 1 + 1;
      }
      if (Nginx != false) {
        size += 1 + 1;
      }
      if (MaxPktSize != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(MaxPktSize);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AppPort other) {
      if (other == null) {
        return;
      }
      if (other.Proto != 0) {
        Proto = other.Proto;
      }
      if (other.InternalPort != 0) {
        InternalPort = other.InternalPort;
      }
      if (other.PublicPort != 0) {
        PublicPort = other.PublicPort;
      }
      if (other.FqdnPrefix.Length != 0) {
        FqdnPrefix = other.FqdnPrefix;
      }
      if (other.EndPort != 0) {
        EndPort = other.EndPort;
      }
      if (other.Tls != false) {
        Tls = other.Tls;
      }
      if (other.Nginx != false) {
        Nginx = other.Nginx;
      }
      if (other.MaxPktSize != 0L) {
        MaxPktSize = other.MaxPktSize;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Proto = (global::DistributedMatchEngine.LProto) input.ReadEnum();
            break;
          }
          case 16: {
            InternalPort = input.ReadInt32();
            break;
          }
          case 24: {
            PublicPort = input.ReadInt32();
            break;
          }
          case 42: {
            FqdnPrefix = input.ReadString();
            break;
          }
          case 48: {
            EndPort = input.ReadInt32();
            break;
          }
          case 56: {
            Tls = input.ReadBool();
            break;
          }
          case 64: {
            Nginx = input.ReadBool();
            break;
          }
          case 72: {
            MaxPktSize = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// DeviceInfoStatic
  /// </summary>
  public sealed partial class DeviceInfoStatic : pb::IMessage<DeviceInfoStatic> {
    private static readonly pb::MessageParser<DeviceInfoStatic> _parser = new pb::MessageParser<DeviceInfoStatic>(() => new DeviceInfoStatic());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceInfoStatic> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DistributedMatchEngine.AppcommonReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoStatic() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoStatic(DeviceInfoStatic other) : this() {
      deviceOs_ = other.deviceOs_;
      deviceModel_ = other.deviceModel_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoStatic Clone() {
      return new DeviceInfoStatic(this);
    }

    /// <summary>Field number for the "device_os" field.</summary>
    public const int DeviceOsFieldNumber = 1;
    private string deviceOs_ = "";
    /// <summary>
    /// Android or iOS
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DeviceOs {
      get { return deviceOs_; }
      set {
        deviceOs_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "device_model" field.</summary>
    public const int DeviceModelFieldNumber = 2;
    private string deviceModel_ = "";
    /// <summary>
    /// Device model
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DeviceModel {
      get { return deviceModel_; }
      set {
        deviceModel_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceInfoStatic);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceInfoStatic other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DeviceOs != other.DeviceOs) return false;
      if (DeviceModel != other.DeviceModel) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DeviceOs.Length != 0) hash ^= DeviceOs.GetHashCode();
      if (DeviceModel.Length != 0) hash ^= DeviceModel.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DeviceOs.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(DeviceOs);
      }
      if (DeviceModel.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(DeviceModel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DeviceOs.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DeviceOs);
      }
      if (DeviceModel.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DeviceModel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceInfoStatic other) {
      if (other == null) {
        return;
      }
      if (other.DeviceOs.Length != 0) {
        DeviceOs = other.DeviceOs;
      }
      if (other.DeviceModel.Length != 0) {
        DeviceModel = other.DeviceModel;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DeviceOs = input.ReadString();
            break;
          }
          case 18: {
            DeviceModel = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///
  /// DeviceInfoDynamic
  /// </summary>
  public sealed partial class DeviceInfoDynamic : pb::IMessage<DeviceInfoDynamic> {
    private static readonly pb::MessageParser<DeviceInfoDynamic> _parser = new pb::MessageParser<DeviceInfoDynamic>(() => new DeviceInfoDynamic());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DeviceInfoDynamic> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::DistributedMatchEngine.AppcommonReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoDynamic() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoDynamic(DeviceInfoDynamic other) : this() {
      dataNetworkType_ = other.dataNetworkType_;
      signalStrength_ = other.signalStrength_;
      carrierName_ = other.carrierName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DeviceInfoDynamic Clone() {
      return new DeviceInfoDynamic(this);
    }

    /// <summary>Field number for the "data_network_type" field.</summary>
    public const int DataNetworkTypeFieldNumber = 1;
    private string dataNetworkType_ = "";
    /// <summary>
    /// LTE, 5G, etc.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DataNetworkType {
      get { return dataNetworkType_; }
      set {
        dataNetworkType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signal_strength" field.</summary>
    public const int SignalStrengthFieldNumber = 2;
    private ulong signalStrength_;
    /// <summary>
    /// Device signal strength
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong SignalStrength {
      get { return signalStrength_; }
      set {
        signalStrength_ = value;
      }
    }

    /// <summary>Field number for the "carrier_name" field.</summary>
    public const int CarrierNameFieldNumber = 3;
    private string carrierName_ = "";
    /// <summary>
    /// Carrier name (can be different from cloudlet org if using "")
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CarrierName {
      get { return carrierName_; }
      set {
        carrierName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DeviceInfoDynamic);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DeviceInfoDynamic other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (DataNetworkType != other.DataNetworkType) return false;
      if (SignalStrength != other.SignalStrength) return false;
      if (CarrierName != other.CarrierName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (DataNetworkType.Length != 0) hash ^= DataNetworkType.GetHashCode();
      if (SignalStrength != 0UL) hash ^= SignalStrength.GetHashCode();
      if (CarrierName.Length != 0) hash ^= CarrierName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (DataNetworkType.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(DataNetworkType);
      }
      if (SignalStrength != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(SignalStrength);
      }
      if (CarrierName.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(CarrierName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (DataNetworkType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DataNetworkType);
      }
      if (SignalStrength != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(SignalStrength);
      }
      if (CarrierName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(CarrierName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DeviceInfoDynamic other) {
      if (other == null) {
        return;
      }
      if (other.DataNetworkType.Length != 0) {
        DataNetworkType = other.DataNetworkType;
      }
      if (other.SignalStrength != 0UL) {
        SignalStrength = other.SignalStrength;
      }
      if (other.CarrierName.Length != 0) {
        CarrierName = other.CarrierName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            DataNetworkType = input.ReadString();
            break;
          }
          case 16: {
            SignalStrength = input.ReadUInt64();
            break;
          }
          case 26: {
            CarrierName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
